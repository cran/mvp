<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Introduction</h1>

<p>The <code>mvp</code> package provides some functionality for fast
manipulation of multivariate polynomials, using the Standard Template
library of <code>C++</code>, commonly known as the <code>STL</code>.  It is
comparable in speed to the <code>spray</code> package for sparse arrays,
while retaining the symbolic capabilities of the <code>mpoly</code> package
[@kahle2013].  The <code>mvp package</code> uses the excellent print and
coercion methods of <code>mpoly</code>.  The <code>mvp</code> package provides
improved speed over <code>mpoly</code>, the ability to handle negative
powers, and a more sophisticated substitution mechanism.</p>

<h1>The <code>STL map</code> class</h1>

<p>A <code>map</code> is a sorted associative container that contains key-value
pairs with unique keys.  It is interesting here because search and
insertion operations have logarithmic complexity.  Multivariate
polynomials are considered to be the sum of a finite number of
<em>terms</em>, each multiplied by a coefficient.  A <em>term</em> is something like
\(x^2y^3z\).  We may consider this term to be the map</p>

<pre><code>{&quot;x&quot; -&gt; 2, &quot;y&quot; -&gt; 3, &quot;z&quot; -&gt; 7}
</code></pre>

<p>the map takes symbols to their (integer) power, and it is understood
that powers are nonzero.  A <code>mvp</code> object is a map from terms to
their coeffients; thus \(7xy^2 -3x^2z^5\) would be</p>

<pre><code>{{&quot;x&quot; -&gt; 2, &quot;y&quot; -&gt; 3, &quot;z&quot; -&gt; 1} -&gt; 7, {&quot;x&quot; -&gt; 2, &quot;z&quot; -&gt;5} -&gt; -7}
</code></pre>

<p>and we understand that coefficients are nonzero.  In <code>C++</code> the
declarations would be</p>

<pre><code>typedef vector &lt;signed int&gt; mypowers;  
typedef vector &lt;string&gt; mynames;  

typedef map &lt;string, signed int&gt; term; 
typedef map &lt;term, double&gt; mvp; 
</code></pre>

<p>Thus a <code>term</code> maps a string to a (signed) integer, and a <code>mvp</code>
maps terms to doubles. </p>

<p>One reason why the <code>map</code> class is fast is that the order in which
the keys are stored is undefined: the compiler may store them in the
order which it regards as most propitious.  This is not an issue for
the maps considered here as addition and multiplication are
commutative and associative.</p>

<p>Note also that constant terms are handled with no difficulty
(constants are simply maps from the empty map to its value), as is the
zero polynomial (which is simply an empty map).</p>

<h2>The package in use</h2>

<p>Consider a simple multivariate polynomial \(3xy+z^3+xy^6z\) and its
representation in the following R session:</p>

<pre><code class="r">library(&quot;mvp&quot;,quietly=TRUE)
p &lt;- as.mvp(&quot;3x y + z^3 + x y^6 z&quot;)
p
#&gt; mvp object algebraically equal to
#&gt; 3 x y  +  x y^6 z  +  z^3
</code></pre>

<p>Coercion and printing are accomplished by the <code>mpoly</code> package
(there is no way I could improve upon Kahle&#39;s work).  Note carefully
that the printed representation of the mvp object is created by the
<code>mpoly</code> package and the print method can rearrange both the terms
of the polynomial (\(3xy+z^3+xy^6z = z^3+3xy+xy^6z\), for example) and
the symbols within a term (\(3xy=3yx\), for example) to display the
polynomial in a human-friendly form.</p>

<p>However, note carefully that such rearranging does not affect the
mathematical properties of the polynomial itself.  In the <code>mvp</code>
package, the order of the terms is not preserved (or even defined) in
the internal representation of the object; and neither is the order of
the symbols within a single term.  Although this might sound odd, if
we consider a marginally more involved situation, such as</p>

<pre><code class="r">M &lt;- as.mvp(&quot;3 stoat*goat^6 -4 + 7 stoatboat^3 * bloat -9 float*boat*goat*gloat^6&quot;)
M
#&gt; mvp object algebraically equal to
#&gt; -4  +  7 bloat stoatboat^3  -  9 boat float gloat^6 goat  +  3 goat^6 stoat
dput(M)
#&gt; structure(list(names = list(character(0), c(&quot;bloat&quot;, &quot;stoatboat&quot;
#&gt; ), c(&quot;boat&quot;, &quot;float&quot;, &quot;gloat&quot;, &quot;goat&quot;), c(&quot;goat&quot;, &quot;stoat&quot;)), 
#&gt;     power = list(integer(0), c(1L, 3L), c(1L, 1L, 6L, 1L), c(6L, 
#&gt;     1L)), coeffs = c(-4, 7, -9, 3)), class = &quot;mvp&quot;)
</code></pre>

<p>it is not clear that any human-discernable ordering is preferable to
any other, and we would be better off letting the compiler decide a
propitious ordering.  In any event, the <code>mpoly</code> package can
specify a print order:</p>

<pre><code class="r">print(M,order=&quot;lex&quot;, varorder=c(&quot;stoat&quot;,&quot;goat&quot;,&quot;boat&quot;,&quot;bloat&quot;,&quot;gloat&quot;,&quot;float&quot;,&quot;stoatboat&quot;))
#&gt; mvp object algebraically equal to
#&gt; 3 stoat goat^6  -  9 goat boat gloat^6 float  +  7 bloat stoatboat^3  -  4
</code></pre>

<h2>Arithmetic operations</h2>

<p>The arithmetic operations <code>*</code>, <code>+</code>, <code>-</code> and <code>^</code> work
as expected:</p>

<pre><code class="r">S1 &lt;- rmvp(5,2,2,4)
S2 &lt;- rmvp(5,2,2,4)
S1
#&gt; mvp object algebraically equal to
#&gt; 5 a b^2  +  3 a c^2  +  a^2  +  2 a^2 c  +  4 b^2 d
S2
#&gt; mvp object algebraically equal to
#&gt; 4 a c  +  4 a c^2  +  2 a^2 c^2  +  5 b d
S1+S2
#&gt; mvp object algebraically equal to
#&gt; 5 a b^2  +  4 a c  +  7 a c^2  +  a^2  +  2 a^2 c  +  2 a^2 c^2  +  5 b d  +  4 b^2 d
S1*S2
#&gt; mvp object algebraically equal to
#&gt; 15 a b c^2 d  +  16 a b^2 c d  +  16 a b^2 c^2 d  +  25 a b^3 d  +  10 a^2 b c d  +  5 a^2 b d  +  20 a^2 b^2 c  +  20 a^2 b^2 c^2  +  8 a^2 b^2 c^2 d  +  12 a^2 c^3  +  12 a^2 c^4  +  10 a^3 b^2 c^2  +  4 a^3 c  +  12 a^3 c^2  +  8 a^3 c^3  +  6 a^3 c^4  +  2 a^4 c^2  +  4 a^4 c^3  +  20 b^3 d^2
S1^2
#&gt; mvp object algebraically equal to
#&gt; 24 a b^2 c^2 d  +  40 a b^4 d  +  16 a^2 b^2 c d  +  30 a^2 b^2 c^2  +  8 a^2 b^2 d  +  25 a^2 b^4  +  9 a^2 c^4  +  10 a^3 b^2  +  20 a^3 b^2 c  +  6 a^3 c^2  +  12 a^3 c^3  +  a^4  +  4 a^4 c  +  4 a^4 c^2  +  16 b^4 d^2
</code></pre>

<h2>Substitution</h2>

<p>The package has two substitution functionalities.  Firstly, we can
substitute one or more variables for a numeric value.  Define a mvp
object:</p>

<pre><code class="r">S3 &lt;- as.mvp(&quot;x + 5x^4*y + 8y^2*x*z^3&quot;)
S3
#&gt; mvp object algebraically equal to
#&gt; x  +  8 x y^2 z^3  +  5 x^4 y
</code></pre>

<p>And then we may substitute \(x=1\):</p>

<pre><code class="r">subs(S3,x=1)
#&gt; mvp object algebraically equal to
#&gt; 1  +  5 y  +  8 y^2 z^3
</code></pre>

<p>Note the natural R idiom, and that the return value is another mvp
object.  We may subsitute for the other variables:</p>

<pre><code class="r">subs(S3,x=1,y=2,z=3)
#&gt; [1] 875
</code></pre>

<p>(in this case, the default behaviour is to return a &ldquo;dropped&rdquo; version
of the resulting polynomial, that is, coerced to a scalar).  The other
mode of substitution is to replace a variable by another polynomial:</p>

<pre><code class="r">subsmvp(S3,&quot;z&quot;,as.mvp(&quot;a^2+2b^3&quot;))
#&gt; mvp object algebraically equal to
#&gt; 96 a^2 b^6 x y^2  +  48 a^4 b^3 x y^2  +  8 a^6 x y^2  +  64 b^9 x y^2  +  x  +  5 x^4 y
</code></pre>

<h2>Differentiation</h2>

<p>Differentiation is implemented.  First we have the <code>deriv()</code>
method:</p>

<pre><code class="r">S &lt;- rmvp(5,4,6,4)
S
#&gt; mvp object algebraically equal to
#&gt; 4 a^4 c^5 d^9  +  2 a^6 c^11  +  5 b^6 c^2 d  +  3 b^7 c^11  +  c^3 d^7
deriv(S,letters[1:3])
#&gt; mvp object algebraically equal to
#&gt; 0
deriv(S,rev(letters[1:3]))  # should be the same.
#&gt; mvp object algebraically equal to
#&gt; 0
</code></pre>

<p>Also a slightly different form:<code>aderiv()</code>, here used to evaluate
\(\frac{\partial^6S}{\partial a^3\partial b\partial c^2}\):</p>

<pre><code class="r">aderiv(S,a=3,b=1,c=2)
#&gt; mvp object algebraically equal to
#&gt; 0
</code></pre>

<h2>Negative powers</h2>

<p>The <code>mvp</code> package handles negative powers, although the idiom is not perfect and I&#39;m still working on it.
There is the <code>invert()</code> function:</p>

<pre><code class="r">p &lt;- as.mvp(&quot;1+x+x^2 y&quot;)
p
#&gt; mvp object algebraically equal to
#&gt; 1  +  x  +  x^2 y
invert(p)
#&gt; mvp object algebraically equal to
#&gt; 1  +  x^-2 y^-1  +  x^-1
</code></pre>

<p>In the above, <code>p</code> is a regular multivariate polynomial which
includes negative powers.  It obeys the same arithmetic rules as other
mvp objects:</p>

<pre><code class="r">p + as.mvp(&quot;z^6&quot;)
#&gt; mvp object algebraically equal to
#&gt; 1  +  x  +  x^2 y  +  z^6
</code></pre>

<p>We can see the generating function for a chess knight:</p>

<pre><code class="r">knight(2)
#&gt; mvp object algebraically equal to
#&gt; a^-2 b^-1  +  a^-2 b  +  a^-1 b^-2  +  a^-1 b^2  +  a b^-2  +  a b^2  +  a^2 b^-1  +  a^2 b
</code></pre>

<p>How many ways are there for a 4D knight to return to its starting
square after four moves?  Answer:</p>

<pre><code class="r">constant(knight(4)^4)
#&gt; [1] 12528
</code></pre>

<h2>Some timings</h2>

<p>I will show some timings using a particularly favourable example that
exploits the symbolic nature of the <code>mvp</code> package.  </p>

<pre><code class="r">library(&quot;spray&quot;)
library(&quot;mpoly&quot;)
n &lt;- 500
k &lt;- kahle(n,r=3,p=1:3,symbols=paste(&quot;x&quot;,sprintf(&quot;%03d&quot;,seq_len(n)),sep=&quot;&quot;))
</code></pre>

<p>In the above, polynomial <code>k</code> has 500 terms of the form \(xy^2z^3\).
Coercing <code>k</code> to <code>spray</code> form would need a \(500\times 500\)
matrix for the indices, almost every element of which would be zero.
This makes the spray package slower:</p>

<pre><code class="r">system.time(ignore &lt;- k^2)
#&gt;    user  system elapsed 
#&gt;   1.914   0.028   1.942
system.time(ignore &lt;- mvp_to_spray(k)^2) 
#&gt;    user  system elapsed 
#&gt;   4.530   0.512   5.042
</code></pre>

<p>In the above, the first line uses <code>mvp</code> functionality, and the
second line uses <code>spray</code> functionality.  The speedup increases for
larger polynomials.</p>

<h1>References</h1>

</body>

</html>
